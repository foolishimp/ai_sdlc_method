#!/usr/bin/env python3
"""
AI SDLC Method v2 - Project Setup

Self-contained installer that can be run directly from GitHub.

# Implements: REQ-TOOL-011 (Installability), REQ-TOOL-003 (Workflow Commands), REQ-TOOL-007 (Project Scaffolding)
# Implements: REQ-TOOL-012 (Multi-Tenant Folder Structure), REQ-TOOL-014 (Observability Integration Contract)

Usage:
    # Install plugin + create v2 workspace (default)
    curl -sL https://raw.githubusercontent.com/foolishimp/ai_sdlc_method/main/imp_claude/code/installers/gen-setup.py | python3 -

    # Install to a specific directory
    python gen-setup.py --target /path/to/project

    # Plugin only (no workspace)
    python gen-setup.py --no-workspace

    # Preview changes without writing
    python gen-setup.py --dry-run

    # Verify existing installation
    python gen-setup.py verify

What gets created:
    .claude/settings.json          - Marketplace + plugin registration
    .ai-workspace/                 - v2 workspace
        events/events.jsonl        - Event log (append-only)
        features/active/           - Active feature vectors
        features/completed/        - Converged feature vectors
        graph/graph_topology.yml   - Asset graph topology (REQ-TOOL-007, REQ-TOOL-014)
        spec/                      - Derived spec views
        tasks/active/              - Task tracking
        tasks/finished/            - Completed tasks
        context/project_constraints.yml - Project constraints (with structure section)
        agents/                    - Per-agent working state
    specification/                 - Spec directory (if absent)
        INTENT.md                  - Intent template
"""

import sys
import json
import argparse
import shutil
import urllib.request
import urllib.error
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, List, Tuple


# =============================================================================
# Configuration
# =============================================================================

GITHUB_REPO = "foolishimp/ai_sdlc_method"
PLUGIN_NAME = "genisis"
MARKETPLACE_NAME = "genisis"
PLUGIN_BASE = f"imp_claude/code/.claude-plugin/plugins/genisis"
PLUGIN_JSON_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/{PLUGIN_BASE}/plugin.json"
GRAPH_TOPOLOGY_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/{PLUGIN_BASE}/config/graph_topology.yml"
BOOTLOADER_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/specification/GENESIS_BOOTLOADER.md"

BOOTLOADER_START_MARKER = "<!-- GENESIS_BOOTLOADER_START -->"
BOOTLOADER_END_MARKER = "<!-- GENESIS_BOOTLOADER_END -->"

VERSION = "2.8.0"


# =============================================================================
# Workspace Templates
# =============================================================================

PROJECT_CONSTRAINTS_TEMPLATE = """\
# Project Constraints — {project_name}
# Implements: REQ-CTX-001 (Context as Constraint Surface)
# Generated by gen-setup.py — fill in during requirements→design edge

project:
  name: "{project_name}"
  kind: ""           # application | library | service | data-pipeline
  language: ""       # auto-detected or user-specified
  test_runner: ""    # auto-detected or user-specified

# Mandatory dimensions (required at requirements→design edge)
constraints:
  ecosystem_compatibility:
    language: ""
    version: ""
    runtime: ""
    frameworks: []
  deployment_target:
    platform: ""
    cloud_provider: ""
    environment_tiers: []
  security_model:
    authentication: ""
    authorisation: ""
    data_protection: ""
  build_system:
    tool: ""
    module_structure: ""
    ci_integration: ""

  # Advisory dimensions (optional, fill when known)
  data_governance:
    classification: ""
    retention: ""
    regulations: []
  performance_envelope:
    p99_latency_ms: null
    throughput_rps: null
  observability:
    logging: ""
    metrics: ""
    tracing: ""
  error_handling:
    strategy: ""     # fail-fast | retry | circuit-breaker

# Multi-tenant folder structure (REQ-TOOL-012, REQ-TOOL-013)
# Controls where design→code edge places generated source code.
# Each design variant gets its own imp_<name>/ directory.
structure:
  design_tenants:
    # - name: ""               # e.g., "scala_spark", "python_django"
    #   output_dir: ""         # e.g., "imp_scala_spark/"
    #   description: ""        # e.g., "Scala 2.13 + Spark 3.5 implementation"
  root_code_policy: reject     # reject | warn — whether source code at project root is allowed
"""

INTENT_TEMPLATE = """\
# {project_name} — Intent

**Intent ID**: INT-001
**Date**: {date}
**Priority**: High
**Status**: Draft

---

## The Problem

<!-- What problem does this project solve? -->

---

## What We Want

<!-- Describe the desired outcome in business language. -->

---

## Business Value

<!-- Why does this matter? Who benefits? -->

---

## Success Criteria

- [ ] Criterion 1
- [ ] Criterion 2

---
"""

ACTIVE_TASKS_TEMPLATE = """\
# Active Tasks

*Last Updated: {date}*

---

No active tasks. Run `/gen-start` to begin.
"""


# =============================================================================
# Helper Functions
# =============================================================================

def print_banner(title: str, version: str = ""):
    """Print setup banner."""
    print()
    print("+" + "=" * 62 + "+")
    title_line = f"AI SDLC Method v2 - {title}"
    padding = (62 - len(title_line)) // 2
    print("|" + " " * padding + title_line + " " * (62 - padding - len(title_line)) + "|")
    if version:
        version_line = f"Version: {version}"
        padding = (62 - len(version_line)) // 2
        print("|" + " " * padding + version_line + " " * (62 - padding - len(version_line)) + "|")
    print("+" + "=" * 62 + "+")
    print()


def print_ok(msg: str):
    print(f"  [OK] {msg}")


def print_error(msg: str):
    print(f"  [ERROR] {msg}")


def print_info(msg: str):
    print(f"  {msg}")


def print_warn(msg: str):
    print(f"  [WARN] {msg}")


def get_plugin_version() -> str:
    """Fetch the latest plugin version from GitHub."""
    try:
        with urllib.request.urlopen(PLUGIN_JSON_URL, timeout=5) as response:
            data = json.loads(response.read().decode("utf-8"))
            return data.get("version", "unknown")
    except (urllib.error.URLError, json.JSONDecodeError, KeyError):
        return VERSION


def fetch_graph_topology() -> str:
    """Fetch graph_topology.yml from GitHub. Falls back to local plugin if available."""
    # Try GitHub first
    try:
        with urllib.request.urlopen(GRAPH_TOPOLOGY_URL, timeout=10) as response:
            return response.read().decode("utf-8")
    except (urllib.error.URLError, OSError):
        pass

    # Fallback: local plugin path (works for local development)
    local_path = Path(__file__).parent.parent / ".claude-plugin" / "plugins" / "genisis" / "config" / "graph_topology.yml"
    if local_path.exists():
        return local_path.read_text()

    return ""


def fetch_bootloader() -> str:
    """Fetch GENESIS_BOOTLOADER.md from GitHub. Falls back to local spec if available."""
    # Try GitHub first
    try:
        with urllib.request.urlopen(BOOTLOADER_URL, timeout=10) as response:
            return response.read().decode("utf-8")
    except (urllib.error.URLError, OSError):
        pass

    # Fallback: local path (works for development in the ai_sdlc_method repo)
    local_path = Path(__file__).resolve().parent.parent.parent.parent / "specification" / "GENESIS_BOOTLOADER.md"
    if local_path.exists():
        return local_path.read_text()

    return ""


def write_file(path: Path, content: str, dry_run: bool, force: bool = False) -> bool:
    """Write file if it doesn't exist (or force is True). Returns True on success."""
    if path.exists() and not force:
        print_info(f"Exists: {path.relative_to(path.parent.parent) if len(path.parts) > 2 else path}")
        return True

    if dry_run:
        print_info(f"Would create: {path}")
        return True

    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        f.write(content)
    print_ok(f"Created {path}")
    return True


def detect_project_name(target: Path) -> str:
    """Auto-detect project name from directory or config files."""
    # Try pyproject.toml
    pyproject = target / "pyproject.toml"
    if pyproject.exists():
        try:
            content = pyproject.read_text()
            for line in content.splitlines():
                if line.strip().startswith("name"):
                    _, _, val = line.partition("=")
                    return val.strip().strip('"').strip("'")
        except Exception:
            pass

    # Try package.json
    pkg = target / "package.json"
    if pkg.exists():
        try:
            data = json.loads(pkg.read_text())
            return data.get("name", target.name)
        except Exception:
            pass

    # Fallback to directory name
    return target.name


# =============================================================================
# Plugin Configuration
# =============================================================================

def clear_plugin_cache(dry_run: bool) -> bool:
    """Clear cached plugin to ensure latest version is fetched."""
    cache_locations = [
        Path.home() / ".claude" / "plugins" / "marketplaces" / MARKETPLACE_NAME,
        Path.home() / ".claude" / "plugins" / "cache" / MARKETPLACE_NAME / PLUGIN_NAME,
    ]

    found_any = False
    for cache_dir in cache_locations:
        if not cache_dir.exists():
            continue
        found_any = True
        if dry_run:
            print_info(f"Would remove: {cache_dir}")
            continue
        try:
            shutil.rmtree(cache_dir)
            print_ok(f"Cleared: {cache_dir}")
        except Exception as e:
            print_warn(f"Could not clear {cache_dir}: {e}")

    if not found_any:
        print_info("No cached plugin found (fresh install)")
    return True


def setup_settings(target: Path, dry_run: bool) -> bool:
    """Create or update .claude/settings.json with marketplace and plugin."""
    settings_file = target / ".claude" / "settings.json"

    existing = {}
    if settings_file.exists():
        try:
            with open(settings_file, "r") as f:
                existing = json.load(f)
        except json.JSONDecodeError:
            print_warn("Existing settings.json has invalid JSON, will merge carefully")

    # Add marketplace
    if "extraKnownMarketplaces" not in existing:
        existing["extraKnownMarketplaces"] = {}
    existing["extraKnownMarketplaces"][MARKETPLACE_NAME] = {
        "source": {"source": "github", "repo": GITHUB_REPO}
    }

    # Enable plugin (hooks are loaded from the plugin's hooks.json by Claude Code)
    if "enabledPlugins" not in existing:
        existing["enabledPlugins"] = {}
    existing["enabledPlugins"][f"{PLUGIN_NAME}@{MARKETPLACE_NAME}"] = True

    if dry_run:
        print_info(f"Would create: {settings_file}")
        return True

    settings_file.parent.mkdir(parents=True, exist_ok=True)
    with open(settings_file, "w") as f:
        json.dump(existing, f, indent=2)
    print_ok(f"Created {settings_file}")
    return True


# =============================================================================
# Workspace Setup (v2 structure)
# =============================================================================

def setup_workspace(target: Path, project_name: str, dry_run: bool) -> bool:
    """Create .ai-workspace/ with v2 structure."""
    now = datetime.now(timezone.utc)
    date_str = now.strftime("%Y-%m-%d %H:%M")
    iso_ts = now.strftime("%Y-%m-%dT%H:%M:%SZ")

    ws = target / ".ai-workspace"

    # Directory structure
    dirs = [
        ws / "events",
        ws / "features" / "active",
        ws / "features" / "completed",
        ws / "graph",
        ws / "spec",
        ws / "tasks" / "active",
        ws / "tasks" / "finished",
        ws / "agents",
    ]

    for d in dirs:
        if dry_run:
            if not d.exists():
                print_info(f"Would create dir: {d.relative_to(target)}")
        else:
            d.mkdir(parents=True, exist_ok=True)

    # Files
    files = {
        ws / "events" / "events.jsonl": "",  # empty — first event appended below
        ws / "tasks" / "active" / "ACTIVE_TASKS.md": ACTIVE_TASKS_TEMPLATE.format(date=date_str),
        ws / "tasks" / "finished" / ".gitkeep": "",
        ws / "features" / "active" / ".gitkeep": "",
        ws / "features" / "completed" / ".gitkeep": "",
        ws / "agents" / ".gitkeep": "",
        ws / "spec" / ".gitkeep": "",
    }

    for path, content in files.items():
        write_file(path, content, dry_run)

    # Project constraints template
    constraints_path = ws / "context" / "project_constraints.yml"
    write_file(
        constraints_path,
        PROJECT_CONSTRAINTS_TEMPLATE.format(project_name=project_name),
        dry_run,
    )

    # Graph topology (REQ-TOOL-007, REQ-TOOL-014 — observability integration contract)
    graph_topology_path = ws / "graph" / "graph_topology.yml"
    if not graph_topology_path.exists():
        if dry_run:
            print_info("Would fetch and create: .ai-workspace/graph/graph_topology.yml")
        else:
            topology_content = fetch_graph_topology()
            if topology_content:
                write_file(graph_topology_path, topology_content, dry_run)
            else:
                print_warn("Could not fetch graph_topology.yml — create manually or re-run with network")
    else:
        print_info("Exists: .ai-workspace/graph/graph_topology.yml")

    # Emit project_initialized event (idempotent — only if events.jsonl is empty)
    events_file = ws / "events" / "events.jsonl"
    if not dry_run:
        if events_file.exists() and events_file.stat().st_size > 0:
            print_info("events.jsonl already has events — skipping project_initialized")
        else:
            event = {
                "event_type": "project_initialized",
                "timestamp": iso_ts,
                "project": project_name,
                "data": {
                    "method_version": VERSION,
                    "installer": "gen-setup.py",
                    "workspace_structure": "v2",
                },
            }
            with open(events_file, "a") as f:
                f.write(json.dumps(event) + "\n")
            print_ok("Emitted project_initialized event")
    else:
        print_info("Would emit project_initialized event")

    return True


def setup_bootloader(target: Path, dry_run: bool) -> bool:
    """Append Genesis Bootloader to CLAUDE.md (idempotent)."""
    claude_md = target / "CLAUDE.md"

    # Check if bootloader already present
    if claude_md.exists():
        existing = claude_md.read_text()
        if BOOTLOADER_START_MARKER in existing:
            print_info("Genesis Bootloader already in CLAUDE.md")
            return True
    else:
        existing = ""

    # Fetch bootloader content
    bootloader = fetch_bootloader()
    if not bootloader:
        print_warn("Could not fetch GENESIS_BOOTLOADER.md — bootloader not installed")
        return False

    if dry_run:
        if existing:
            print_info("Would append Genesis Bootloader to existing CLAUDE.md")
        else:
            print_info("Would create CLAUDE.md with Genesis Bootloader")
        return True

    # Build the section to append
    separator = "\n\n---\n\n" if existing.strip() else ""
    bootloader_section = (
        f"{separator}"
        f"{BOOTLOADER_START_MARKER}\n"
        f"{bootloader}\n"
        f"{BOOTLOADER_END_MARKER}\n"
    )

    with open(claude_md, "a") as f:
        f.write(bootloader_section)

    if existing:
        print_ok("Appended Genesis Bootloader to CLAUDE.md")
    else:
        print_ok("Created CLAUDE.md with Genesis Bootloader")
    return True


def setup_specification(target: Path, project_name: str, dry_run: bool) -> bool:
    """Create specification/ directory with INTENT.md template if absent."""
    spec_dir = target / "specification"
    intent_file = spec_dir / "INTENT.md"

    if intent_file.exists():
        print_info(f"Exists: specification/INTENT.md")
        return True

    date_str = datetime.now().strftime("%Y-%m-%d")
    write_file(
        intent_file,
        INTENT_TEMPLATE.format(project_name=project_name, date=date_str),
        dry_run,
    )
    return True


# =============================================================================
# Verify Command
# =============================================================================

def cmd_verify(args) -> int:
    """Verify an existing installation."""
    target = Path(args.target).resolve()
    print_banner("Installation Verify", VERSION)

    passed = 0
    failed = 0

    # Detect install mode: if .ai-workspace/ is absent but .claude/settings.json
    # exists, this is a --no-workspace (plugin-only) install.
    has_workspace = (target / ".ai-workspace").is_dir()
    has_settings = (target / ".claude" / "settings.json").exists()
    plugin_only = has_settings and not has_workspace

    if plugin_only:
        print_info("Detected: plugin-only install (--no-workspace)")
        print()

    # Plugin checks (always)
    checks = [
        (target / ".claude" / "settings.json", "Plugin settings"),
    ]

    # Workspace checks (only for full installs)
    if not plugin_only:
        checks += [
            (target / ".ai-workspace" / "events" / "events.jsonl", "Event log"),
            (target / ".ai-workspace" / "features" / "active", "Feature vectors dir"),
            (target / ".ai-workspace" / "graph" / "graph_topology.yml", "Graph topology"),
            (target / ".ai-workspace" / "tasks" / "active" / "ACTIVE_TASKS.md", "Task tracking"),
            (target / ".ai-workspace" / "context" / "project_constraints.yml", "Project constraints"),
        ]

    for path, label in checks:
        if path.exists():
            print_ok(f"{label}: {path.relative_to(target)}")
            passed += 1
        else:
            print_error(f"{label}: MISSING — {path.relative_to(target)}")
            failed += 1

    # Genesis Bootloader check (only for full installs — bootloader is part of workspace flow)
    if not plugin_only:
        claude_md = target / "CLAUDE.md"
        if claude_md.exists():
            claude_content = claude_md.read_text()
            if BOOTLOADER_START_MARKER in claude_content:
                print_ok("Genesis Bootloader present in CLAUDE.md")
                passed += 1
            else:
                print_error("Genesis Bootloader NOT in CLAUDE.md — re-run installer")
                failed += 1
        else:
            print_error("CLAUDE.md missing — re-run installer")
            failed += 1

    # Check settings content
    settings_file = target / ".claude" / "settings.json"
    if settings_file.exists():
        try:
            settings = json.loads(settings_file.read_text())
            mkts = settings.get("extraKnownMarketplaces", {})
            plugins = settings.get("enabledPlugins", {})

            if MARKETPLACE_NAME in mkts:
                print_ok(f"Marketplace '{MARKETPLACE_NAME}' registered")
                passed += 1
            else:
                print_error(f"Marketplace '{MARKETPLACE_NAME}' not in settings")
                failed += 1

            plugin_key = f"{PLUGIN_NAME}@{MARKETPLACE_NAME}"
            if plugins.get(plugin_key):
                print_ok(f"Plugin '{plugin_key}' enabled")
                passed += 1
            else:
                print_error(f"Plugin '{plugin_key}' not enabled")
                failed += 1

        except Exception as e:
            print_error(f"Cannot parse settings.json: {e}")
            failed += 1

    # Check events (only for full installs)
    if not plugin_only:
        events_file = target / ".ai-workspace" / "events" / "events.jsonl"
        if events_file.exists() and events_file.stat().st_size > 0:
            try:
                first_line = events_file.read_text().strip().splitlines()[0]
                evt = json.loads(first_line)
                if evt.get("event_type") == "project_initialized":
                    print_ok(f"project_initialized event present")
                    passed += 1
                else:
                    print_warn(f"First event is '{evt.get('event_type')}', not project_initialized")
            except Exception:
                print_warn("Cannot parse first event")

    print()
    print("=" * 64)
    print(f"  Checks: {passed} passed, {failed} failed")
    if failed == 0:
        print("  Installation verified OK")
    else:
        print("  Installation incomplete — re-run installer to fix")
    print()

    return 0 if failed == 0 else 1


# =============================================================================
# Default Command — Install
# =============================================================================

def cmd_install(args) -> int:
    """Default command: plugin + workspace setup."""
    target = Path(args.target).resolve()
    project_name = detect_project_name(target)

    version = get_plugin_version()
    print_banner("Project Setup", version)

    print_info(f"Target:  {target}")
    print_info(f"Project: {project_name}")
    print_info(f"Plugin:  {PLUGIN_NAME} v{version}")
    print_info(f"Workspace: {'No' if args.no_workspace else 'Yes (v2 structure)'}")
    if args.dry_run:
        print_warn("DRY RUN — no changes will be made")
    print()

    success = True

    # 1. Clear plugin cache
    print("--- Plugin Cache ---")
    clear_plugin_cache(args.dry_run)
    print()

    # 2. Configure plugin (marketplace + enablement; hooks come from plugin)
    print("--- Plugin Configuration ---")
    if not setup_settings(target, args.dry_run):
        success = False
    print()

    # 3. Create workspace
    if not args.no_workspace:
        print("--- Workspace (v2) ---")
        if not setup_workspace(target, project_name, args.dry_run):
            success = False
        print()

        print("--- Specification ---")
        if not setup_specification(target, project_name, args.dry_run):
            success = False
        print()

        # 3b. Append bootloader to CLAUDE.md
        print("--- Genesis Bootloader ---")
        if not setup_bootloader(target, args.dry_run):
            success = False
        print()

    # Summary
    print("=" * 64)
    if args.dry_run:
        print("  Dry run complete — no changes made")
    elif success:
        print("  Setup complete!")
        print()
        print("  What was created:")
        print("    .claude/settings.json          Plugin config (GitHub marketplace)")
        if not args.no_workspace:
            print("    .ai-workspace/events/          Event log (source of truth)")
            print("    .ai-workspace/features/        Feature vector storage")
            print("    .ai-workspace/graph/           Graph topology (monitor integration)")
            print("    .ai-workspace/tasks/           Task tracking")
            print("    .ai-workspace/context/         Project constraints (with structure)")
            print("    specification/INTENT.md        Intent template")
            print("    CLAUDE.md                      Genesis Bootloader (appended)")
        print()
        print("  Next steps:")
        print("    1. Start Claude Code (it will prompt to install the marketplace)")
        print("    2. Run /plugin install genisis@genisis")
        print("    3. Run /gen-start to begin")
        print()
        print("  Verify installation:")
        print("    python gen-setup.py verify")
    else:
        print("  Setup completed with errors")
    print()

    return 0 if success else 1


# =============================================================================
# Main
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="AI SDLC Method v2 — Project Setup",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""\
Examples:
  # Install from GitHub (one-liner)
  curl -sL https://raw.githubusercontent.com/foolishimp/ai_sdlc_method/main/imp_claude/code/installers/gen-setup.py | python3 -

  # Install to current directory
  python gen-setup.py

  # Preview changes
  python gen-setup.py --dry-run

  # Verify installation
  python gen-setup.py verify
""",
    )

    subparsers = parser.add_subparsers(dest="command")

    # Verify subcommand
    verify_parser = subparsers.add_parser("verify", help="Verify existing installation")
    verify_parser.add_argument("--target", default=".", help="Target directory")

    # Default command arguments
    parser.add_argument("--target", default=".", help="Target directory")
    parser.add_argument("--no-workspace", action="store_true", help="Skip .ai-workspace/ creation")
    parser.add_argument("--dry-run", action="store_true", help="Preview changes without writing")

    args = parser.parse_args()

    if args.command == "verify":
        return cmd_verify(args)
    else:
        return cmd_install(args)


if __name__ == "__main__":
    sys.exit(main())
