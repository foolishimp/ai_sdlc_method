# Affect Triage Pipeline Configuration
# Implements: REQ-SENSE-003, REQ-SENSE-004, REQ-SENSE-005, REQ-LIFE-006
# Reference: AISDLC_V2_DESIGN.md §1.8.4, §1.8.5, §1.8.6
#
# Tiered triage: rule-based classification first (fast, pattern-matching),
# agent-classified only for ambiguous signals (slow, Bedrock Converse API).
# Triage assigns classification, severity, and escalation decision.
# Above-threshold signals generate draft proposals via review boundary.

---

version: "1.0.0"

# ═══════════════════════════════════════════════════════════════════════
# CLASSIFICATION RULES (Rule-based — fast)
# ═══════════════════════════════════════════════════════════════════════
#
# Evaluated in order. First matching rule wins.
# Unmatched signals fall through to agent classification.

classification_rules:

  # ─── Vulnerability signals (exteroceptive) ───────────────────────
  - name: critical_vulnerability
    pattern:
      monitor_type: exteroceptive
      monitor_id: EXTRO-002
      severity: critical
    classification: vulnerability
    default_severity: critical
    escalation: always

  - name: medium_vulnerability
    pattern:
      monitor_type: exteroceptive
      monitor_id: EXTRO-002
      severity: [medium, high]
    classification: vulnerability
    default_severity: warning
    escalation: threshold

  # ─── Contract break (exteroceptive) ──────────────────────────────
  - name: api_breaking_change
    pattern:
      monitor_id: EXTRO-004
    classification: contract_break
    default_severity: critical
    escalation: always

  # ─── Runtime deviation (exteroceptive) ───────────────────────────
  - name: runtime_spike
    pattern:
      monitor_id: EXTRO-003
    classification: runtime_deviation
    default_severity: critical
    escalation: always

  # ─── Degradation signals (interoceptive) ─────────────────────────
  - name: test_coverage_drop
    pattern:
      monitor_id: INTRO-003
      metric_delta: "> 5%"
    classification: degradation
    default_severity: warning
    escalation: threshold

  - name: build_failure_rate
    pattern:
      monitor_id: INTRO-005
      metric_value: "> threshold"
    classification: degradation
    default_severity: warning
    escalation: threshold

  # ─── Staleness signals (interoceptive) ───────────────────────────
  - name: event_staleness
    pattern:
      monitor_id: INTRO-001
      metric_value: "> threshold"
    classification: staleness
    default_severity: info
    escalation: threshold

  - name: feature_stall
    pattern:
      monitor_id: INTRO-002
      metric_value: "> threshold"
    classification: staleness
    default_severity: warning
    escalation: threshold

  - name: status_lag
    pattern:
      monitor_id: INTRO-004
      metric_value: "> threshold"
    classification: staleness
    default_severity: info
    escalation: threshold

  # ─── Drift signals (interoceptive) ───────────────────────────────
  - name: spec_code_drift
    pattern:
      monitor_id: INTRO-006
    classification: drift
    default_severity: warning
    escalation: threshold

  # ─── Ecosystem signals (exteroceptive) ───────────────────────────
  - name: dependency_update
    pattern:
      monitor_id: EXTRO-001
    classification: ecosystem_change
    default_severity: info
    escalation: threshold

  # ─── Integrity signals (interoceptive) ───────────────────────────
  - name: event_log_corruption
    pattern:
      monitor_id: INTRO-007
    classification: integrity
    default_severity: warning
    escalation: always

  # ─── Meta-monitoring (monitor failure) ───────────────────────────
  - name: monitor_failure
    pattern:
      monitor_id: META-001
    classification: meta_failure
    default_severity: warning
    escalation: threshold

  # ─── Fallback: unmatched → agent classification ──────────────────
  - name: agent_fallback
    pattern:
      unmatched: true
    classification: agent_classify
    escalation: agent_decides

# ═══════════════════════════════════════════════════════════════════════
# ESCALATION THRESHOLDS (per profile)
# ═══════════════════════════════════════════════════════════════════════
#
# Each profile defines the minimum severity for escalation.
# "always" escalation ignores the threshold.
# "threshold" escalation compares signal severity against the profile.

escalation_thresholds:

  full:
    minimum_severity: info         # escalate everything
    description: "Maximum sensitivity — all signals reach conscious review"

  standard:
    minimum_severity: warning      # skip info-level signals
    description: "Balanced — warning and above reach conscious review"

  hotfix:
    minimum_severity: info         # escalate everything (emergency mode)
    description: "Emergency — all signals escalated for rapid response"

  spike:
    minimum_severity: critical     # only critical signals
    description: "Exploration focus — suppress noise, only critical signals"

  poc:
    minimum_severity: critical     # only critical signals
    description: "Construction focus — suppress non-critical signals"

  minimal:
    minimum_severity: warning      # sensible defaults
    description: "Sensible defaults — warning and above"

# ═══════════════════════════════════════════════════════════════════════
# AGENT CLASSIFICATION (for unmatched signals)
# ═══════════════════════════════════════════════════════════════════════
#
# When rule-based classification fails, invoke Bedrock Converse API for
# classification. This is the "slow path" — only for ambiguous signals.

agent_classification:
  model: us.anthropic.claude-3-5-haiku-20241022-v1:0    # fast, cheap model for classification
  prompt_template: |
    You are a signal classifier for the AI SDLC sensory system.
    Given this signal, classify it and recommend an escalation decision.

    Signal:
    - Monitor: {monitor_id}
    - Observation: {observation}
    - Metric value: {metric_value}
    - Threshold: {threshold}

    Classify as one of: vulnerability, degradation, staleness, drift,
    ecosystem_change, contract_break, runtime_deviation, integrity, meta_failure

    Assign severity: info, warning, critical

    Recommend escalation: escalate, defer, log_only

  output_schema:
    classification: string
    severity: string
    escalation_decision: string
    reasoning: string

# ═══════════════════════════════════════════════════════════════════════
# REVIEW BOUNDARY (REQ-SENSE-005)
# ═══════════════════════════════════════════════════════════════════════
#
# API Gateway endpoints exposed by the Bedrock sensory service. These
# constitute the review boundary separating autonomous sensing from
# human-approved changes. The sensory service CANNOT modify workspace
# state directly — all modifications go through the API after human
# approval.

review_boundary:
  api_gateway_endpoints:
    review_submit:
      method: POST
      path: /api/v1/reviews
      description: "Submit a review decision for a pending proposal"
      params: [vector_id, decision, comments]
      returns: confirmation_and_events
      modifies_state: true    # applied after human approval, not autonomously

    review_status:
      method: GET
      path: /api/v1/reviews/{review_id}
      description: "Retrieve status and details of a specific review"
      params: [review_id]
      returns: review_detail_with_trigger_chain
      modifies_state: false

    escalation_create:
      method: POST
      path: /api/v1/escalations
      description: "Create an escalation for a signal requiring human attention"
      params: [vector_id, reason, priority]
      returns: escalation_id_and_status
      modifies_state: false

    proposals_list:
      method: GET
      path: /api/v1/proposals
      description: "List pending draft proposals with full context"
      params: [status, limit, offset]
      returns: proposal_list_with_trigger_chains
      modifies_state: false

    proposals_dismiss:
      method: POST
      path: /api/v1/proposals/{proposal_id}/dismiss
      description: "Dismiss a proposal with reason (logged for learning)"
      params: [proposal_id, reason]
      returns: dismissal_logged
      modifies_state: false

    monitor_status:
      method: GET
      path: /api/v1/monitors
      description: "Current state of all monitors, last run times, signal counts"
      params: []
      returns: monitor_health_dashboard
      modifies_state: false

    monitor_config:
      method: GET
      path: /api/v1/monitors/config
      description: "View monitor configuration and thresholds"
      params: []
      returns: current_config
      modifies_state: false

  # The review boundary enforces:
  # 1. All state modifications go through human oversight (REQ-EVAL-003)
  # 2. Two distinct event categories:
  #    - sensor/evaluate: autonomous, observation-only
  #    - change-approval: conscious, human-approved
  autonomy_model: draft_only
  human_required_for: [state_modification, event_emission, feature_vector_update]

# ═══════════════════════════════════════════════════════════════════════
# TRIAGE EVENT SCHEMA
# ═══════════════════════════════════════════════════════════════════════
#
# Every triage decision is logged to events.jsonl as affect_triage.

event_schema:
  event_type: affect_triage
  fields:
    timestamp: ISO-8601
    signal_id: "ref to interoceptive_signal or exteroceptive_signal"
    source_monitor: "monitor_id that generated the signal"
    classification: "vulnerability | degradation | staleness | drift | ecosystem_change | contract_break | runtime_deviation | integrity | meta_failure"
    severity: "info | warning | critical"
    escalation_decision: "escalate | defer | log_only | dismissed"
    recommended_action: "human-readable recommendation"
    affected_req_keys: "list of REQ-* keys if traceable"
    profile_threshold: "the active threshold that caused escalation"
    classified_by: "rule | agent"
